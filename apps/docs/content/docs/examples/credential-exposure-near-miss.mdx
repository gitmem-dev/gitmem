---
title: "The Credential Leak"
description: An AI agent almost prints API keys to a recorded terminal session. Institutional memory blocks it.
---

# The Credential Leak

An agent needs to check whether environment variables are configured. The fastest way? `echo $API_KEY`. But in a recorded session, that value is now permanently stored â€” in transcripts, recordings, and conversation history. This is the kind of mistake that's invisible until it's catastrophic.

## The Situation

An agent was setting up a deployment pipeline inside a container. It needed to verify that three API keys were available before proceeding:

```bash
# The agent's first instinct
echo $PAYMENT_API_KEY
echo $STORAGE_SECRET
echo $AUTH_TOKEN
```

This would work â€” the values would print, the agent would confirm they exist, and the deployment would proceed. But the session was being recorded. Every command and its output was captured in:

1. A session transcript stored in a database
2. An asciinema recording (`.cast` file) synced to shared storage
3. The conversation history persisted across sessions

If those `echo` commands ran, the actual secret values would be permanently embedded in at least three storage systems. Rotating the keys wouldn't help â€” the old values would still exist in historical records.

The correct approach uses existence checks that never expose values:

```bash
# Safe: only checks if the variable is set
[ -n "$PAYMENT_API_KEY" ] && echo "SET" || echo "MISSING"
[ -n "$STORAGE_SECRET" ] && echo "SET" || echo "MISSING"
[ -n "$AUTH_TOKEN" ] && echo "SET" || echo "MISSING"
```

## The Scar

After a near-miss where an agent almost printed credentials during a debugging session, this scar was created:

```json
{
  "learning_type": "scar",
  "title": "Never print environment variable VALUES â€” only check existence",
  "description": "When checking if environment variables exist, NEVER run commands that output the actual values (e.g., echo $SECRET, env | grep KEY). Secret values will be captured in session recordings, transcripts, and conversation history. Instead, check existence only: test with [ -n \"$VAR\" ] && echo \"SET\" || echo \"MISSING\".",
  "severity": "critical",
  "scar_type": "incident",
  "counter_arguments": [
    "You might think showing a prefix is safe â€” but partial keys are still sensitive and the full value is in the raw output before truncation",
    "You might think CLI sessions are ephemeral â€” but recordings and transcripts persist them permanently",
    "You might think it's fine because it's a local container â€” but recordings sync to shared directories and transcripts go to the database"
  ]
}
```

Three things make this scar effective:

1. **Critical severity** ensures it surfaces with high priority during recall â€” it won't be buried below medium-severity results.

2. **Three counter-arguments** address three distinct rationalizations. Each one is a real thought process that would lead an agent to print secrets anyway: "partial keys are fine," "sessions are temporary," "containers are isolated."

3. **The scar type is `incident`** (not `process`), meaning it decays over 180 days. If the team later builds infrastructure-level protection (like a pre-execution hook that blocks secret-printing commands), the scar becomes less critical and naturally fades.

## The Save

In a later session, an agent was debugging a failing API integration and needed to verify credentials were loaded. It called `recall` before running diagnostic commands:

```
recall({ plan: "check environment variables for API configuration" })
```

GitMem surfaced the scar:

```
ðŸ§  INSTITUTIONAL MEMORY ACTIVATED

Found 2 relevant scars for your plan:

ðŸ”´ Never print environment variable VALUES â€” only check
   existence (critical, score: 0.82)
   When checking if environment variables exist, NEVER run
   commands that output the actual values...
```

The agent confirmed:

```
confirm_scars([{
  scar_id: "...",
  decision: "APPLYING",
  evidence: "Used [ -n \"$VAR\" ] && echo SET || echo MISSING for all three API keys. No secret values were printed to the session.",
  relevance: "high"
}])
```

Instead of `echo $API_KEY`, the agent ran safe existence checks. The credentials stayed secret. The session recording contained only "SET" or "MISSING" â€” no actual values.

## The Takeaway

This example demonstrates three properties of effective institutional memory:

### Critical scars justify infrastructure investment

This scar was so important that it eventually led to a `PreToolUse` hook â€” an automated gate that blocks commands matching credential-exposure patterns before they execute. The scar came first, proved the risk was real, and justified building the permanent fix. Scars can be the evidence that earns engineering investment.

### Counter-arguments address rationalizations, not just facts

"Partial keys are safe" and "containers are isolated" aren't factual errors â€” they're reasonable-sounding arguments that happen to be wrong in this context. By documenting them explicitly, the scar prevents the agent from independently re-deriving the same flawed reasoning.

### Incident scars have built-in expiration

Unlike process scars (which never decay), this incident scar fades over 180 days. If the team ships a hook that structurally prevents credential exposure, the scar becomes redundant â€” and the system knows it. This prevents scar accumulation from becoming a burden.
