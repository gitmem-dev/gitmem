[
  {
    "id": "00000000-0000-0000-0000-000000000002",
    "learning_type": "scar",
    "title": "Done != Deployed != Verified Working",
    "description": "Code being 'done' (merged) doesn't mean it's deployed, and being deployed doesn't mean it's working correctly in production. The full loop is: merge → deploy → verify the feature works end-to-end in the target environment. Skipping verification leads to silent failures.",
    "severity": "critical",
    "scar_type": "verification",
    "is_starter": true,
    "counter_arguments": [
      "Our deployment pipeline is automated so merge = deploy — but automated doesn't mean verified working",
      "We have monitoring that would catch issues — but monitoring has blind spots and alert fatigue is real"
    ],
    "keywords": ["deployment", "verification", "production", "done"],
    "domain": ["deployment", "operations"],
    "project": "default",
    "source_date": "2026-01-01",
    "created_at": "2026-01-01T00:00:00Z"
  },
  {
    "id": "00000000-0000-0000-0000-000000000004",
    "learning_type": "scar",
    "title": "Database Migration Without Rollback Plan",
    "description": "Running database migrations without a tested rollback plan risks data loss or extended downtime. Destructive migrations (dropping columns, changing types) are especially dangerous. Always write and test the down migration before running the up migration in production.",
    "severity": "critical",
    "scar_type": "architectural",
    "is_starter": true,
    "counter_arguments": [
      "This migration is additive so it's safe — but even additive migrations can fail and leave the schema in a partial state",
      "We can always restore from backup — but backup restoration takes time and may lose recent data"
    ],
    "keywords": ["database", "migration", "rollback", "schema", "data-loss"],
    "domain": ["database", "operations"],
    "project": "default",
    "source_date": "2026-01-01",
    "created_at": "2026-01-01T00:00:00Z"
  },
  {
    "id": "00000000-0000-0000-0000-000000000010",
    "learning_type": "scar",
    "title": "Silent Error Swallowing Hides Real Failures",
    "description": "Empty catch blocks and generic error handlers that log but don't surface errors lead to silent failures. The system appears to work while data is lost or corrupted. At minimum, log errors with enough context to diagnose the issue. Better: fail visibly so problems are caught early.",
    "severity": "high",
    "scar_type": "operational",
    "is_starter": true,
    "counter_arguments": [
      "We catch errors to prevent crashes — but catching without handling is worse than crashing because the problem is hidden",
      "The error is non-critical so swallowing it is fine — but 'non-critical' errors compound and mask the root cause of critical issues"
    ],
    "keywords": ["error-handling", "catch", "silent-failure", "logging"],
    "domain": ["error-handling", "debugging"],
    "project": "default",
    "source_date": "2026-01-01",
    "created_at": "2026-01-01T00:00:00Z"
  }
]
