# GitMem — Complete Documentation

> GitMem is an MCP server that gives AI coding agents persistent institutional memory.
> Install: `npx gitmem-mcp init` or add MCP server `npx -y gitmem-mcp`
> Source: https://gitmem.ai
> Index: https://gitmem.ai/llms.txt

========================================================================
# Changelog
URL: https://gitmem.ai/docs/changelog
Description: GitMem release history.
========================================================================

# Changelog

## v1.0.2 (2026-02-15)

### Features

- **`npx gitmem init`** — Interactive setup wizard that detects existing config, prompts, and merges without destroying anything. Replaces the multi-step manual setup.
  - 6 steps: memory store, MCP server, CLAUDE.md, permissions, hooks, gitignore
  - Flags: `--yes` (non-interactive), `--dry-run` (preview), `--project <name>`
  - Idempotent — re-running safely skips completed steps
- **`npx gitmem uninstall`** — Clean reversal of everything init did. Memory data (`.gitmem/`) preserved by default, `--all` to also delete.

### Docs

- Updated README to feature one-command setup, added gitmem.ai link
- Updated docs site installation and getting-started pages

## v1.0.1 (2026-02-14)

### Bug Fixes

- Fixed stdout corruption — 22 `console.log` calls replaced with `console.error` in check.ts
- Error messages now surface in `create_learning` and `record_scar_usage` responses via `errors[]` array
- Session ID validation added to `session_close` — returns clear error with UUID format example instead of confusing DB lookup failure
- Removed hardcoded project enum — project names are now free-form strings

### Tests

- +2 regression tests for stdout purity
- +8 tests for error message surfacing
- +10 tests for session ID validation

## v1.0.0 (2026-02-15)

### Initial Release

- 23 core tools (free tier) / 29 tools (pro tier)
- Session management with closing ceremony
- Scar recall with semantic search
- Thread tracking across sessions
- Multi-agent context injection
- Knowledge graph traversal
- Local `.gitmem/` storage (free) or Supabase (pro)
- Claude Code hooks for automatic session management
- 660+ automated tests across 6 tiers

========================================================================
# Core Concepts
URL: https://gitmem.ai/docs/concepts
Description: Understand the building blocks of GitMem's institutional memory system.
========================================================================

# Core Concepts

GitMem is built around a few key ideas that work together to give AI agents persistent, actionable memory.

## The Memory Loop

```
recall → work → learn → close → recall → ...
```

1. **Recall** — Before acting, check what you've learned before
2. **Work** — Do the task, applying past lessons
3. **Learn** — Capture new scars, wins, and patterns
4. **Close** — Persist session context for next time

## Key Concepts

- [Scars](/docs/concepts/scars) — Mistakes captured as institutional memory, surfaced before you repeat them
- [Sessions](/docs/concepts/sessions) — Bounded work periods with context loading and closing ceremonies
- [Threads](/docs/concepts/threads) — Unresolved work that carries across sessions
- [Learning Types](/docs/concepts/learning-types) — Scars, wins, patterns, and anti-patterns
- [Tiers](/docs/concepts/tiers) — Free (local) vs Pro (Supabase) capabilities

========================================================================
# Learning Types
URL: https://gitmem.ai/docs/concepts/learning-types
Description: The four types of institutional memory in GitMem.
========================================================================

# Learning Types

GitMem supports four types of institutional memory, each serving a different purpose.

## Scars

**Mistakes to avoid.** The most common learning type. Scars are surfaced automatically via `recall` when an agent plans a similar action.

```json
{
  "learning_type": "scar",
  "title": "Always validate UUID format before DB lookup",
  "severity": "medium",
  "counter_arguments": ["Internal-only tools may trust input", "UUIDs from trusted sources are pre-validated"]
}
```

**Required fields:** title, description, severity, counter_arguments (2+)

See [Scars](/docs/concepts/scars) for details.

## Wins

**Approaches that worked well.** Capture what succeeded so you can replicate it.

```json
{
  "learning_type": "win",
  "title": "Parallel agent spawning cut review time by 60%",
  "problem_context": "Code review of 500-line PR was taking too long with sequential analysis",
  "solution_approach": "Spawned 3 agents in parallel: one for logic, one for tests, one for security"
}
```

**Required fields:** title, description

## Patterns

**Reusable strategies.** Document approaches that work in specific contexts.

```json
{
  "learning_type": "pattern",
  "title": "5-Tier Test Pyramid for MCP Servers",
  "applies_when": ["shipping MCP servers to npm", "pre-release verification"]
}
```

**Required fields:** title, description

## Anti-Patterns

**Approaches that seem good but aren't.** Document why a seemingly reasonable approach fails.

```json
{
  "learning_type": "anti_pattern",
  "title": "Don't use console.log in MCP servers",
  "description": "MCP uses stdio for JSON-RPC. Any console.log corrupts the transport. Use console.error for diagnostics."
}
```

**Required fields:** title, description

## Severity Levels

Severity applies to scars and determines surfacing priority:

| Level | Meaning | Example |
|-------|---------|---------|
| `critical` | Data loss or security risk | "Never store API keys in git" |
| `high` | Significant time waste or user impact | "Done != Deployed != Verified" |
| `medium` | Moderate friction or repeated issue | "Always validate UUIDs before DB lookup" |
| `low` | Minor optimization or preference | "Use descriptive branch names" |

========================================================================
# Local Storage
URL: https://gitmem.ai/docs/concepts/local-storage
Description: How GitMem uses the local filesystem, what persists across sessions, and container deployment considerations.
========================================================================

import { Callout } from 'fumadocs-ui/components/callout'

# Local Storage

GitMem writes to the local filesystem for session state, caching, and free-tier data storage. This page maps exactly what lives where so you can make informed decisions about persistence — especially in containers.

## Storage Locations

| Location | What | Owner |
|----------|------|-------|
| `<project>/.gitmem/` | Session state, threads, config, caches | GitMem MCP server |
| `~/.cache/gitmem/` | Search result cache (15-min TTL) | GitMem MCP server |

## File Inventory

```
.gitmem/
+-- active-sessions.json          # Process lifecycle
+-- config.json                   # Project defaults
+-- sessions.json                 # Recent session index (free tier SOT)
+-- threads.json                  # Thread state cache / free tier SOT
+-- suggested-threads.json        # AI-suggested threads
+-- closing-payload.json          # (ephemeral -- deleted after use)
+-- cache/
|   +-- hook-scars.json           # Local scar copy for hooks plugin
+-- hooks-state/
|   +-- start_time                # Session start timestamp
|   +-- tool_call_count           # Recall nag counter
|   +-- last_nag_time             # Last recall reminder time
|   +-- stop_hook_active          # Lock file (re-entrancy guard)
|   +-- audit.jsonl               # Hook execution log
+-- sessions/
    +-- <session-uuid>/
        +-- session.json          # Per-session state (scars, confirmations)
```

**Total typical footprint: ~530KB** (dominated by `cache/hook-scars.json`).

## File Lifecycle

| File | Created | Survives Session Close? |
|------|---------|------------------------|
| `active-sessions.json` | `session_start` | Yes — multi-session registry |
| `config.json` | First `session_start` | Yes |
| `sessions.json` | `session_close` (free tier) | Yes |
| `threads.json` | `session_close` | Yes |
| `suggested-threads.json` | `session_close` | Yes |
| `closing-payload.json` | Agent writes before close | **No** — ephemeral |
| `cache/hook-scars.json` | Hooks plugin startup | Yes |
| `sessions/<id>/session.json` | `session_start` | **No** — cleaned up on close |

## Cross-Session Data Flow

### What `session_start` loads

| Data | Pro/Dev Source | Free Source |
|------|---------------|-------------|
| Last session (decisions, reflection) | Supabase `sessions` | `.gitmem/sessions.json` |
| Open threads | Supabase `threads` | `.gitmem/threads.json` |
| Recent decisions | Supabase `decisions` | `.gitmem/sessions.json` (embedded) |
| Scars for recall | Supabase `learnings` | `.gitmem/learnings.json` |
| Suggested threads | `.gitmem/suggested-threads.json` | `.gitmem/suggested-threads.json` |

### What `recall` searches

| Tier | Source | Search Method |
|------|--------|---------------|
| Pro/Dev | Supabase `learnings` | Semantic (embedding cosine similarity) |
| Pro/Dev (cached) | `~/.cache/gitmem/results/` | Local vector search (15-min TTL) |
| Free | `.gitmem/learnings.json` | Keyword tokenization match |

### What `session_close` persists

| Data | Pro/Dev Destination | Free Destination |
|------|--------------------|--------------------|
| Session record | Supabase `sessions` | `.gitmem/sessions.json` |
| New learnings | Supabase `learnings` | `.gitmem/learnings.json` |
| Decisions | Supabase `decisions` | `.gitmem/decisions.json` |
| Thread state | Supabase `threads` + local | `.gitmem/threads.json` |
| Scar usage | Supabase `scar_usage` | `.gitmem/scar_usage.json` |
| Transcript | Supabase storage bucket | Not captured |

## Container Deployments

### Ephemeral container per session

```
Container A (session 1) -> writes .gitmem/ -> container destroyed
Container B (session 2) -> fresh .gitmem/ -> no history
```

| Tier | Cross-Session Memory | What Breaks |
|------|---------------------|-------------|
| **Pro/Dev** | **Works** — Supabase is SOT | Hooks plugin cold-starts each time. Suggested threads lost. Minor UX friction, no data loss. |
| **Free** | **Completely broken** — all memory is local files | No scars, no threads, no session history. Each session is amnesic. |

### Persistent volume mount

```bash
docker run -v gitmem-data:/app/.gitmem ...
```

Both tiers work. Free tier: local files ARE the SOT. Pro tier: local files are caches, Supabase is SOT.

### Shared container (long-running)

Container stays alive across multiple `claude` invocations. Both tiers work. `.gitmem/` persists because the container persists.

## Recommendations

### Free tier

Mount a volume for `.gitmem/`:

```yaml
volumes:
  - gitmem-state:/workspace/.gitmem
```

Files that MUST persist: `learnings.json`, `threads.json`, `sessions.json`, `decisions.json`.

### Pro/Dev tier

**Nothing required.** Supabase is the source of truth. A fresh `.gitmem/` each session works — just slightly slower (cache cold start).

Optional for better UX:

```yaml
volumes:
  - gitmem-cache:/workspace/.gitmem/cache  # Avoids scar cache re-download
```

<Callout type="info" title="Why local files exist at all on pro tier">
`active-sessions.json` tracks process lifecycle (PIDs, hostnames) — inherently local. `sessions/<id>/session.json` survives context compaction when the LLM loses state. `cache/hook-scars.json` is needed by shell-based hooks that can't call Supabase directly. `closing-payload.json` avoids MCP tool call size limits.
</Callout>

========================================================================
# Scars
URL: https://gitmem.ai/docs/concepts/scars
Description: How GitMem captures and surfaces mistakes as institutional memory.
========================================================================

# Scars

A **scar** is a mistake captured as institutional memory. When an AI agent encounters a problem, the lesson is recorded as a scar so that future agents (or future sessions of the same agent) don't repeat it.

## How Scars Work

1. **Something goes wrong** — A deployment fails, a bug slips through, a wrong assumption costs time
2. **The scar is created** — The lesson is captured with title, description, severity, and counter-arguments
3. **Future recall surfaces it** — When an agent plans a similar action, the scar appears automatically

## Scar Anatomy

```json
{
  "learning_type": "scar",
  "title": "Done != Deployed != Verified Working",
  "description": "Marking a task as done after committing code is not enough. The full loop is: commit → push → deploy → verify the service is running and accessible.",
  "severity": "high",
  "scar_type": "process",
  "counter_arguments": [
    "For local-only changes, deployment verification is unnecessary",
    "In CI/CD pipelines, deployment may be automatic"
  ]
}
```

### Required Fields

| Field | Purpose |
|-------|---------|
| `title` | Short, memorable name for the lesson |
| `description` | Detailed explanation of what went wrong and how to avoid it |
| `severity` | `critical`, `high`, `medium`, or `low` |
| `counter_arguments` | At least 2 reasons why someone might reasonably ignore this scar |

### Scar Types

| Type | Decay | Use When |
|------|-------|----------|
| `process` | Never | The lesson is about how to work (e.g., "always run tests before pushing") |
| `incident` | 180 days | A specific incident that may become less relevant over time |
| `context` | 30 days | Temporary context (e.g., "API X is down, use fallback") |

## Counter-Arguments

Every scar **requires** at least 2 counter-arguments. This prevents scar accumulation from becoming a burden. Counter-arguments document when it's reasonable to ignore the scar.

Good counter-arguments:
- Describe specific scenarios where the scar doesn't apply
- Acknowledge trade-offs (speed vs safety)
- Note when the underlying cause has been fixed

## The Confirm Protocol

When scars are surfaced via `recall`, the agent must **confirm** each one before proceeding:

- **APPLYING** — "I've accounted for this lesson" (with evidence)
- **N_A** — "This scar doesn't apply to my current situation" (with reasoning)
- **REFUTED** — "I'm deliberately overriding this scar" (acknowledging risk)

This ensures scars are actively considered, not just passively displayed.

========================================================================
# Sessions
URL: https://gitmem.ai/docs/concepts/sessions
Description: How GitMem tracks bounded work periods with context loading and closing ceremonies.
========================================================================

# Sessions

A **session** is a bounded work period. It starts when an agent calls `session_start` and ends with `session_close`. Sessions provide continuity between conversations.

## Session Lifecycle

### 1. Start

`session_start` initializes a session and loads context:

- Creates a unique session ID
- Loads the last session's context (threads, decisions, rapport notes)
- Identifies the agent type (CLI, Desktop, etc.)
- Returns a formatted session banner

### 2. Work

During the session, the agent:
- Calls `recall` before consequential actions
- Creates learnings (scars, wins, patterns)
- Logs decisions
- Tracks threads for unfinished work

### 3. Close

`session_close` persists the session:

- **Quick close** — Minimal, for short exploratory sessions
- **Standard close** — Full reflection with 9 questions covering what broke, what worked, and what to remember

## Session State

Session state is stored in `.gitmem/`:

```
.gitmem/
├── active-sessions.json         # Registry of active sessions
└── sessions/
    └── <session-id>/
        └── session.json         # Session data, scars surfaced, etc.
```

## Context Loading

When a new session starts, GitMem loads:

| Context | Source | Purpose |
|---------|--------|---------|
| Open threads | `threads.json` | Unfinished work to continue |
| Recent decisions | Last session | Architectural context |
| Rapport notes | Last session | How the human prefers to work |

## The Closing Ceremony

Standard close asks 9 questions:

1. What broke that you didn't expect?
2. What took longer than it should have?
3. What would you do differently next time?
4. What pattern or approach worked well?
5. What assumption was wrong?
6. Which scars did you apply?
7. What should be captured as institutional memory?
8. How did the human prefer to work? *(rapport)*
9. What collaborative dynamic worked? *(rapport)*

These reflections become context for the next session.

========================================================================
# Threads
URL: https://gitmem.ai/docs/concepts/threads
Description: Track unresolved work across sessions with lifecycle management, vitality scoring, and semantic deduplication.
========================================================================

import { Callout } from 'fumadocs-ui/components/callout'

# Threads

**Threads** are persistent work items that carry across sessions. They track what's unresolved, what's blocked, and what needs follow-up — surviving session boundaries so nothing gets lost.

## Why Threads Exist

Sessions end, but work doesn't. Before threads, open items lived as plain strings inside session records. They had no IDs, no lifecycle, no way to mark something as done. You'd see the same stale item surfaced session after session with no way to clear it.

Threads give open items identity (`t-XXXXXXXX`), lifecycle status, vitality scoring, and a resolution trail.

## Creating Threads

```
create_thread({ text: "Auth middleware needs rate limiting before production deploy" })
```

Threads are created in three ways:

1. **Explicitly** via `create_thread` — mid-session when you identify a new open item
2. **Implicitly** via `session_close` — when the closing payload includes `open_threads`
3. **Promoted** from a suggestion via `promote_suggestion` — when a recurring topic is confirmed

## Thread Lifecycle

Threads progress through a 5-stage state machine based on vitality scoring and age:

```
create_thread / session_close payload
        |
        v
  [ EMERGING ]  -- first 24 hours, high visibility
        |
        v (age > 24h)
  [ ACTIVE ]  -- vitality > 0.5, actively referenced
        |
        v (vitality decays)
  [ COOLING ]  -- 0.2 <= vitality <= 0.5, fading from use
        |
        v (vitality < 0.2)
  [ DORMANT ]  -- vitality < 0.2, no recent touches
        |
        v (dormant 30+ days)
  [ ARCHIVED ]  -- auto-archived, hidden from session_start

Any state --(explicit resolve_thread)--> [ RESOLVED ]
```

### Transitions

| Transition | Condition |
|-----------|-----------|
| any -> emerging | Thread age < 24 hours |
| emerging -> active | Thread age >= 24 hours, vitality > 0.5 |
| active -> cooling | Vitality drops to [0.2, 0.5] |
| cooling -> active | Touch refreshes vitality above 0.5 |
| cooling -> dormant | Vitality drops below 0.2 |
| dormant -> active | Touch refreshes vitality above 0.5 |
| dormant -> archived | Dormant for 30+ consecutive days |
| any -> resolved | Explicit `resolve_thread` call |

**Terminal states:** Archived and resolved threads do not transition. To reopen an archived topic, create a new thread.

## Vitality Scoring

Every thread has a vitality score (0.0 to 1.0) computed from two components:

```
vitality = 0.55 * recency + 0.45 * frequency
```

### Recency

Exponential decay based on thread class half-life:

```
recency = e^(-ln(2) * days_since_touch / half_life)
```

| Thread Class | Half-Life | Use Case |
|-------------|-----------|----------|
| operational | 3 days | Deploys, fixes, incidents, blockers |
| backlog | 21 days | Research, long-running improvements |

Thread class is auto-detected from keywords in the thread text ("deploy", "fix", "debug", "hotfix", "urgent", "broken", "incident", "blocker" = operational).

### Frequency

Log-scaled touch count normalized against thread age:

```
frequency = min(log(touch_count + 1) / log(days_alive + 1), 1.0)
```

### Status Thresholds

| Vitality Score | Status |
|---------------|--------|
| > 0.5 | active |
| 0.2 - 0.5 | cooling |
| < 0.2 | dormant |

Threads touched during a session have their `touch_count` incremented and `last_touched_at` refreshed, which revives decayed vitality.

## Carry-Forward

On `session_start`, open threads appear with vitality info:

```
Open threads (3):
  t-abc12345: Fix auth timeout [ACTIVE 0.82] (operational, 2d ago)
  t-def67890: Improve test coverage [COOLING 0.35] (backlog, 12d ago)
  t-ghi11111: New thread just created [EMERGING 0.95] (backlog, today)
```

## Resolution

Threads are resolved via `resolve_thread`:
- **By ID** (preferred): `resolve_thread({ thread_id: "t-a1b2c3d4" })`
- **By text match** (fallback): `resolve_thread({ text_match: "package name" })`

Resolution records a timestamp, the resolving session, and an optional note. Knowledge graph triples are written to track the resolution relationship.

## Semantic Deduplication

When `create_thread` is called, the new thread text is compared against all open threads using embedding cosine similarity before creation.

| Threshold | Value | Meaning |
|-----------|-------|---------|
| Dedup similarity | 0.85 | Above this = duplicate |

**Dedup methods** (in priority order):
1. **Embedding-based** — cosine similarity of text embeddings (when Supabase available)
2. **Text normalization fallback** — exact match after lowercasing, stripping punctuation, collapsing whitespace

When a duplicate is detected, the existing thread is returned (with `deduplicated: true`) and touched to keep it vital.

## Suggested Threads

At `session_close`, session embeddings are compared to detect recurring topics that should become threads.

### Detection Algorithm

1. Compare current session embedding against the last 20 sessions (30-day window)
2. Find sessions with cosine similarity >= 0.70
3. If 3+ sessions cluster (current + 2 historical):
   - Check if an open thread already covers the topic (>= 0.80) -> skip
   - Check if a pending suggestion already matches (>= 0.80) -> add evidence
   - Otherwise, create a new suggestion

Suggestions appear at `session_start`:

```
Suggested threads (2) -- recurring topics not yet tracked:
  ts-a1b2c3d4: Recurring auth timeout pattern (3 sessions)
  ts-e5f6g7h8: Build performance regression (4 sessions)
  Use promote_suggestion or dismiss_suggestion to manage.
```

| Action | Tool | Effect |
|--------|------|--------|
| Promote | `promote_suggestion` | Converts to a real thread |
| Dismiss | `dismiss_suggestion` | Suppresses (3x = permanent) |

## Knowledge Graph Integration

Thread creation and resolution generate knowledge graph triples:

| Predicate | Subject | Object | When |
|-----------|---------|--------|------|
| `created_thread` | Session | Thread | Thread created |
| `resolves_thread` | Session | Thread | Thread resolved |
| `relates_to_thread` | Thread | Issue | Thread linked to Linear issue |

Use `graph_traverse` to query these relationships with 4 lenses: `connected_to`, `produced_by`, `provenance`, `stats`.

## Managing Threads

| Tool | Purpose |
|------|---------|
| [`create_thread`](/docs/tools/create-thread) | Create a new open thread |
| [`resolve_thread`](/docs/tools/resolve-thread) | Mark a thread as done |
| [`list_threads`](/docs/tools/list-threads) | See all open threads |
| [`cleanup_threads`](/docs/tools/cleanup-threads) | Triage by health (active/cooling/dormant) |
| [`promote_suggestion`](/docs/tools/promote-suggestion) | Convert suggestion to real thread |
| [`dismiss_suggestion`](/docs/tools/dismiss-suggestion) | Suppress a suggestion |

## Storage

| Location | Purpose | Tier |
|----------|---------|------|
| `.gitmem/threads.json` | Runtime cache / free tier SOT | All |
| `.gitmem/suggested-threads.json` | Pending suggestions | All |
| Supabase `threads` table | Source of truth (full vitality, lifecycle, embeddings) | Pro/Dev |
| Supabase `sessions.open_threads` | Legacy fallback | Pro/Dev |

<Callout type="info" title="Free vs Pro">
On free tier, `.gitmem/threads.json` IS the source of truth. On pro/dev tier, it's a cache — Supabase is authoritative.
</Callout>

========================================================================
# Tiers
URL: https://gitmem.ai/docs/concepts/tiers
Description: GitMem's tier system and how it affects available features.
========================================================================

# Tiers

GitMem has three tiers that control which tools and storage backends are available.

## Free

- **Storage:** Local `.gitmem/` directory
- **Search:** Local vector cache
- **Tools:** 23 core tools
- **Cost:** $0
- **Best for:** Solo developers, single-machine workflows

Set via: `GITMEM_TIER=free` (default)

## Pro (Coming Soon)

- **Storage:** Supabase PostgreSQL with pgvector
- **Search:** Semantic search via embeddings
- **Tools:** 29 tools (adds batch, transcripts, cache management)
- **Best for:** Teams, multi-machine workflows, production use

Pro is currently in development. [Join the mailing list](https://gitmem.ai) to get notified when it launches.

## Additional Tools (Pro)

These tools will be available when Pro launches:

| Tool | Purpose |
|------|---------|
| `record_scar_usage_batch` | Record multiple scar applications at once |
| `save_transcript` | Save session transcript to storage |
| `get_transcript` | Retrieve a saved transcript |
| `search_transcripts` | Semantic search over transcript chunks |
| `cache_status` | Show local cache status |
| `cache_health` | Compare local cache vs remote |
| `cache_flush` | Force reload from Supabase |

========================================================================
# MCP Protocol Compliance
URL: https://gitmem.ai/docs/contributing/compliance
Description: Full MCP protocol compliance report — 36/36 tests passing.
========================================================================

import { Callout } from 'fumadocs-ui/components/callout'

# MCP Protocol Compliance

<Callout type="success" title="36/36 PASS">
GitMem passes all MCP protocol compliance tests as of v1.0.3.
</Callout>

## Running the Suite

```bash
GITMEM_TIER=free node tests/compliance/mcp-protocol-compliance.mjs
```

The compliance test script spawns the MCP server as a child process via STDIO, performs the full JSON-RPC 2.0 handshake, validates tool schemas, executes tool calls, and tests error handling.

## Results Summary

| Category | Tests | Result |
|----------|-------|--------|
| Protocol Handshake | 9 | 9/9 |
| Tool Listing | 4 | 4/4 |
| Schema Validation | 3 | 3/3 |
| Tool Execution | 10 | 10/10 |
| Error Handling | 4 | 4/4 |
| Response Format | 6 | 6/6 |
| **Total** | **36** | **36/36** |

## Category Details

### 1. Protocol Handshake (9/9)

Tests JSON-RPC 2.0 `initialize` method and `notifications/initialized` lifecycle.

| Test | Result |
|------|--------|
| initialize returns result | PASS |
| has protocolVersion | PASS |
| protocolVersion is string | PASS |
| has serverInfo | PASS |
| serverInfo.name exists | PASS |
| serverInfo.version exists | PASS |
| has capabilities | PASS |
| capabilities.tools exists | PASS |
| initialized notification accepted | PASS |

### 2. Tool Listing (4/4)

| Test | Result |
|------|--------|
| tools/list returns result | PASS |
| result has tools array | PASS |
| at least 1 tool registered | PASS |
| tool count (21) is reasonable (5-100) | PASS |

21 tools in free tier. Pro tier exposes 67, dev tier 73.

### 3. Tool Schema Validation (3/3)

Every tool's `inputSchema` validated against JSON Schema and MCP spec requirements.

| Test | Result |
|------|--------|
| all tool schemas valid (type, required, property types, descriptions) | PASS |
| all descriptions >= 30 chars | PASS |
| no duplicate tool names | PASS |

### 4. Tool Execution (10/10)

Live tool calls via MCP STDIO transport.

| Test | Result |
|------|--------|
| gitmem-help returns result | PASS |
| result has content array | PASS |
| content[0].type === "text" | PASS |
| content[0].text is non-empty | PASS |
| search returns result | PASS |
| search result has content | PASS |
| search content is text type | PASS |
| recall returns result | PASS |
| recall has content array | PASS |
| log returns result | PASS |

### 5. Error Handling (4/4)

| Test | Result |
|------|--------|
| unknown tool returns error | PASS |
| unknown method returns JSON-RPC error | PASS |
| error has numeric code | PASS |
| error code is -32601 (Method not found) | PASS |

### 6. Response Format Compliance (6/6)

| Test | Result |
|------|--------|
| all responses include jsonrpc: "2.0" | PASS |
| all responses include matching id | PASS |
| content block has type field | PASS |
| text block has text field | PASS |
| successful calls have isError=false or undefined | PASS |
| resources/list returns -32601 (not implemented) | PASS |

## Optional Features Not Implemented

These are valid omissions — the MCP spec does not require servers to implement all capabilities:

| Feature | Status | Reason |
|---------|--------|--------|
| `resources/list` | Not implemented (-32601) | No resources exposed; tools-only server |
| `prompts/list` | Not implemented (-32601) | No prompt templates; tool-driven UX |
| `resources/templates/list` | Not implemented | No dynamic resources |

========================================================================
# Contributing
URL: https://gitmem.ai/docs/contributing
Description: How to contribute to GitMem.
========================================================================

# Contributing

GitMem is open source. Contributions are welcome.

## Development Setup

```bash
git clone https://github.com/nTEG-dev/gitmem
cd gitmem
npm install
npm run build
```

## Running Tests

```bash
# Unit tests (fast, no deps)
npm run test:unit

# Smoke tests (MCP server boot)
npx vitest run --config vitest.smoke.config.ts

# All tests
npm test
```

See [Testing](/docs/contributing/testing) for the full test pyramid.

## Project Structure

```
gitmem/
├── src/
│   ├── server.ts           # MCP server entry
│   ├── tools/              # Tool implementations
│   │   ├── definitions.ts  # Tool schemas (source of truth)
│   │   ├── recall.ts       # Scar surfacing
│   │   ├── session-start.ts
│   │   └── ...
│   ├── services/           # Business logic
│   │   ├── tier.ts         # Tier gating
│   │   ├── startup.ts      # Cache initialization
│   │   └── ...
│   └── types/              # TypeScript types
├── tests/
│   ├── unit/               # Unit tests
│   ├── smoke/              # Smoke tests
│   ├── integration/        # Integration tests (Docker)
│   └── e2e/                # End-to-end tests
├── apps/
│   └── docs/               # This documentation site
└── docs/                   # Internal development docs
```

## Submitting Changes

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/my-change`
3. Make your changes with tests
4. Run the test suite: `npm test`
5. Submit a pull request

## Code Style

- TypeScript strict mode
- ESM-only (no CommonJS)
- `console.error` for diagnostics (never `console.log` — it corrupts MCP stdio)

========================================================================
# Testing
URL: https://gitmem.ai/docs/contributing/testing
Description: GitMem's 6-tier test pyramid, CI pipeline, and how to run each tier.
========================================================================

import { Tabs, Tab } from 'fumadocs-ui/components/tabs'
import { Callout } from 'fumadocs-ui/components/callout'

# Testing

GitMem uses a 6-tier testing pyramid. Each tier adds cost/time but tests closer to the real user experience.

## Test Pyramid

| Tier | Command | Tests | Speed | Cost | What it tests |
|------|---------|-------|-------|------|---------------|
| **1 - Unit** | `npm run test:unit` | 597 | ~3s | Free | Schema validation, pure functions, golden regressions |
| **2 - Smoke** | `npm run test:smoke` | 9 | ~5s | Free | MCP server boot, tool registration, basic tool calls via stdio |
| **3 - Integration** | `npm run test:integration` | 63 | ~30s | Free (Docker) | Real PostgreSQL, session lifecycle, cache behavior, query plans |
| **4 - E2E** | `npm run test:e2e` | 68 | ~90s | Free (Docker for pro) | CLI install flow, hooks, free/pro tier MCP via stdio |
| **5 - User Journey** | `npm run test:e2e -- tests/e2e/user-journey.test.ts` | 6 | ~60s | API calls | Real Claude session via Agent SDK |
| **6 - Performance** | `npm run test:perf` | benchmarks | ~30s | Free | Cold start, recall latency, cache hit rate microbenchmarks |

**Run all:** `npm run test:all` (runs tiers 1-4 + 6; excludes user-journey)

<Callout type="info" title="Before pushing">
Always run `npm run test:unit` at minimum. Before shipping to npm, run tiers 1-5. Tier 5 (User Journey) is the most important gate.
</Callout>

## Quick Run (No Docker)

For development, run the tests that don't need Docker:

```bash
npm run test:unit && npx vitest run --config vitest.smoke.config.ts
```

This covers 670+ tests in under 10 seconds.

---

## Tier Details

### Tier 1 — Unit Tests (597 tests, 34 files)

Pure unit tests with no external dependencies. Fast, deterministic, run everywhere.

| Category | Files | What it covers |
|----------|-------|----------------|
| **Schemas** | 13 files | Zod schema validation for all tool inputs |
| **Services** | 11 files | Thread manager, active sessions, file locks, gitmem-dir, timezone |
| **Tools** | 2 files | absorb-observations, prepare-context |
| **Hooks** | 2 files | format-utils, quick-retrieve |
| **Diagnostics** | 4 files | anonymizer, channels, check-command, collector |
| **Golden Regressions** | 1 file | 11 tests replaying specific historical bugs |
| **Standalone** | 3 files | Variant assignment and enforcement (21 tests) |

### Tier 2 — Smoke Tests (9 tests, 2 files)

Boot the MCP server via stdio transport and verify basic functionality.

| Suite | Tests | What it covers |
|-------|-------|----------------|
| `smoke-free.test.ts` | 4 | Free tier server boot, tool list, basic recall |
| `smoke-pro.test.ts` | 5 | Pro tier server boot (skips without Supabase credentials) |

### Tier 3 — Integration Tests (63 tests, 5 files)

Tests against a real PostgreSQL database via Testcontainers. Catches issues mocks would miss: missing indexes, query plan regressions, schema drift.

All tests share a single Testcontainers setup that starts `pgvector/pgvector:pg16`, stubs `auth.role()` for Supabase compatibility, and loads `schema/setup.sql`.

| Suite | Tests | What it covers |
|-------|-------|----------------|
| `fresh-install.test.ts` | ~12 | Empty database behavior, first session, first learning |
| `session-lifecycle.test.ts` | ~15 | Session create/close, concurrent sessions, close compliance |
| `cache-behavior.test.ts` | 9 | Cache file operations, TTL expiry, cache symmetry |
| `query-plans.test.ts` | ~12 | Index usage verification (EXPLAIN), query performance at scale |
| `scale-profiles.test.ts` | ~15 | Behavior at 0, 15, 100, 500, 1000 scars |

### Tier 4 — E2E Tests (68 tests, 6 files)

Tests CLI commands and MCP protocol end-to-end. Pro tests spawn Testcontainers.

| Suite | Tests | What it covers |
|-------|-------|----------------|
| `cli-fresh-install.test.ts` | 27 | `gitmem init`, `gitmem check`, `gitmem install-hooks`, output sanitization |
| `free-tier.test.ts` | 15 | Free tier MCP: session lifecycle, recall, create_learning, parameter validation |
| `pro-fresh.test.ts` | 11 | Pro tier with PostgreSQL: tool registration, recall, session lifecycle |
| `pro-mature.test.ts` | 7 | Pro tier at scale (1000 scars): performance, cache hit rate, throughput |
| `organic-discovery.test.ts` | 2 | Multi-session organic adoption measurement (API calls) |
| `user-journey.test.ts` | 6 | Real Claude session (see Tier 5) |

### Tier 5 — User Journey (6 tests)

The most important pre-ship gate. Spawns a real Claude session and verifies the full user experience using the [Claude Agent SDK](https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/sdk).

What it verifies:
1. SessionStart hook fires with correct ceremony wording
2. MCP tools are registered and connected
3. Agent calls `session_start` and `recall`
4. No internal references leak into output
5. Session completes successfully

### Tier 6 — Performance Benchmarks

Vitest `bench()` microbenchmarks measuring operation latency with statistical rigor.

| Suite | What it benchmarks |
|-------|--------------------|
| `cold-start.bench.ts` | Cache initialization, first session start |
| `recall.bench.ts` | Local vector search at 15 and 1000 scars |
| `cache.bench.ts` | Cache key generation |
| `session-start.bench.ts` | Session start components |

#### Performance Baselines

| Component | Baseline (ms) |
|-----------|--------------|
| `session_start_total` | 750 |
| `recall_with_scars` | 2000 |
| `recall_empty` | 500 |
| `scar_search_local` | 100 |
| `session_close_total` | 1500 |
| `cache_hit` | 5 |

Tests fail if measurement exceeds baseline x 1.5 (alert threshold).

---

## CI Pipeline

Source: `.github/workflows/ci.yml`

**Triggers:** Push to `main`, `v*` tags, PRs against `main`.

### Build Job (matrix: Node 18, 20, 22)

| Step | Command | What it does |
|------|---------|-------------|
| Type check | `npm run typecheck` | `tsc --noEmit` |
| Build | `npm run build` | `tsc` — compile to `dist/` |
| Unit tests | `npm run test:unit` | 764 tests via vitest |
| Smoke test | `npm run test:smoke:free` | 4 MCP integration tests |

### Publish Job (tag pushes only)

Runs after all 3 build matrix jobs pass. Only fires on `v*` tag pushes.

### Release Workflow

```bash
# 1. Make changes, commit
# 2. Bump version
npm version patch
# 3. Tag and push
git tag v1.0.X
git push origin main --tags
# CI builds -> tests -> publishes automatically
```

### What's NOT in CI

| Test tier | Why not | How to run |
|-----------|---------|-----------|
| Integration (Tier 3) | Needs Docker | `npm run test:integration` locally |
| E2E pro (Tier 4) | Needs Docker | `npm run test:e2e` locally |
| User Journey (Tier 5) | Needs Claude API key | `npm run test:e2e -- tests/e2e/user-journey.test.ts` |
| Performance (Tier 6) | Benchmarks, not pass/fail | `npm run test:perf` |

---

## Prerequisites

### Docker (Tiers 3-4)

Integration and pro E2E tests use [Testcontainers](https://node.testcontainers.org/) to spin up `pgvector/pgvector:pg16` PostgreSQL containers.

- Docker daemon must be running (`docker info` must succeed)
- Tests skip gracefully when Docker is unavailable
- Docker-in-Docker: mount the host Docker socket (`/var/run/docker.sock`)

### Auth Schema Stub

Plain pgvector PostgreSQL doesn't include Supabase's `auth` schema. All Docker-based tests must stub it:

```sql
CREATE SCHEMA IF NOT EXISTS auth;
CREATE OR REPLACE FUNCTION auth.role() RETURNS TEXT AS $$
  SELECT 'service_role'::TEXT;
$$ LANGUAGE sql;
```

### Claude CLI (Tier 5)

User Journey tests require the Claude CLI installed and authenticated. Detection: `claude --version`.

---

## Skip Conditions

Tests skip gracefully when dependencies are missing:

| Test | Skip condition | Detection |
|------|---------------|-----------|
| `user-journey.test.ts` | Claude CLI not installed | `claude --version` |
| `organic-discovery.test.ts` | Claude CLI not installed | `claude --version` |
| `pro-fresh.test.ts` | Docker not available | `docker info` |
| `pro-mature.test.ts` | Docker not available | `docker info` |
| `smoke-pro.test.ts` | No Supabase credentials | env check |
| All integration tests | Docker not available | `docker info` |

---

## Tool Tier Gating

The MCP server gates tools by tier:

| Tier | Tool Count | Includes |
|------|-----------|----------|
| **free** | 55 | Core tools only |
| **pro** | 67 | + analyze, cache management, graph traverse |
| **dev** | 73 | + batch operations, transcripts |

---

## Mapping Changes to Test Tiers

Test at the tier where your change first touches a real boundary. Every change gets Tier 1. Then add the tier that matches the highest boundary crossed.

```
Did you change...
  +- a pure function or schema?          -> Tier 1 (always)
  +- how the MCP server responds?        -> + Tier 2 (5s, free)
  +- a database query or migration?      -> + Tier 3 (30s, Docker)
  +- a CLI command or hook script?       -> + Tier 4 (90s, Docker for pro)
  +- what the agent experiences?          -> + Tier 5 (60s, ~$0.30)
  +- performance-sensitive code?          -> + Tier 6 (30s, free)
```

### Pre-commit Minimum

| Situation | Run |
|-----------|-----|
| Any code change | `npm run test:unit` (Tier 1) |
| MCP server or tool changes | + `npm run test:smoke:free` (Tier 2) |
| Before pushing to GitHub | Tiers 1 + 2 minimum |
| Before npm publish | Tiers 1-5 (Tier 5 is the ship gate) |

---

## Agent SDK Testing Pattern

The `user-journey.test.ts` file establishes a reusable pattern for testing Claude CLI integrations:

```typescript
import { query } from "@anthropic-ai/claude-agent-sdk";
import type { SDKMessage, HookCallback, PreToolUseHookInput } from "@anthropic-ai/claude-agent-sdk";

const toolCalls: string[] = [];
const hookObserver: HookCallback = async (input) => {
  if (input.hook_event_name === "PreToolUse") {
    toolCalls.push((input as PreToolUseHookInput).tool_name);
  }
  return {};
};

for await (const msg of query({
  prompt: "Do something",
  options: {
    cwd: "/path/to/project",
    model: "haiku",
    maxTurns: 5,
    maxBudgetUsd: 1.0,
    permissionMode: "bypassPermissions",
    allowDangerouslySkipPermissions: true,
    persistSession: false,
    settingSources: ["project"],
    thinking: { type: "disabled" },
    hooks: {
      PreToolUse: [{ hooks: [hookObserver] }],
    },
  },
})) {
  // Process messages...
}

expect(toolCalls).toContain("mcp__gitmem__session_start");
```

### Key SDK Options for Testing

| Option | Value | Why |
|--------|-------|-----|
| `model` | `"haiku"` | Fastest, cheapest |
| `maxTurns` | 2-5 | Prevent runaway |
| `maxBudgetUsd` | 1.0 | Hard cost cap |
| `permissionMode` | `"bypassPermissions"` | No interactive prompts |
| `persistSession` | `false` | No disk state |
| `settingSources` | `["project"]` | Load project hooks |

---

## Adding New Tests

| What you're adding | Tier | Location |
|-------------------|------|----------|
| Schema validation / pure logic | 1 | `tests/unit/schemas/` or `tests/unit/services/` |
| Database behavior | 3 | `tests/integration/` |
| Free tier CLI / hooks | 4 | `cli-fresh-install.test.ts` or `free-tier.test.ts` |
| Pro tier MCP | 4 | `pro-fresh.test.ts` or `pro-mature.test.ts` |
| Agent behavior | 5 | `user-journey.test.ts` |
| Performance regression | 6 | `tests/performance/` |
| Hook scripts | — | `hooks/tests/test-hooks.sh` |

<Callout type="warn" title="Non-deterministic agents">
For Tier 5 user-journey tests, keep prompts simple and use `appendSystemPrompt` to constrain agent behavior. Test that tools are _called_, not that the agent says specific words.
</Callout>

## MCP Protocol Compliance

A dedicated compliance suite validates gitmem-mcp against the MCP protocol specification. See [Compliance Report](/docs/contributing/compliance) for the full report.

**Latest result:** 36/36 PASS

```bash
GITMEM_TIER=free node tests/compliance/mcp-protocol-compliance.mjs
```

========================================================================
# Configuration
URL: https://gitmem.ai/docs/getting-started/configuration
Description: Configure GitMem with environment variables and config files.
========================================================================

# Configuration

GitMem works out of the box with zero configuration on the free tier. For Pro tier features (Supabase storage, semantic search), you'll need environment variables.

## Environment Variables

| Variable | Default | Purpose |
|----------|---------|---------|
| `GITMEM_DIR` | `.gitmem/` | Override the storage directory location |
| `GITMEM_DEFAULT_PROJECT` | `default` | Default project namespace for scoping |

## Storage

### Free Tier (Local)

All data stored in `.gitmem/` relative to your project root:

```
.gitmem/
├── active-sessions.json    # Current session registry
├── sessions/               # Session data per session ID
├── learnings/              # Scars, wins, patterns (JSON)
├── decisions/              # Decision log
├── threads/                # Open threads tracking
└── cache/                  # Local vector search cache
```

Add `.gitmem/` to your `.gitignore` — session data is machine-specific.

### Pro Tier (Coming Soon)

Pro will add Supabase PostgreSQL with pgvector for semantic search, cross-machine sync, and shared team memory. [Join the mailing list](https://gitmem.ai) to get notified.

## Project Namespaces

GitMem supports arbitrary project names to scope sessions and searches:

```
session_start({ project: "my-api" })
recall({ plan: "add auth", project: "my-api" })
```

Projects are free-form strings. Use them to separate concerns when working across multiple codebases or domains.

========================================================================
# Your First Session
URL: https://gitmem.ai/docs/getting-started/first-session
Description: Walk through a complete GitMem session from start to close.
========================================================================

# Your First Session

This walkthrough shows you what a GitMem-powered session looks like from your AI agent's perspective.

## 1. Open a Session

```
> "Start a GitMem session"
```

The agent calls `session_start`, which:
- Creates a session with a unique ID
- Loads context from the last session (threads, decisions, rapport)
- Displays a session banner with status

## 2. Recall Before Acting

Before making changes, the agent checks institutional memory:

```
> "Add authentication to the API"
```

The agent calls `recall` with the plan "add authentication":

```
recall({ plan: "add authentication to the API" })
```

GitMem returns relevant scars:
- "JWT token expiry must be validated server-side, not just client-side"
- "Always hash passwords with bcrypt, not SHA-256"

The agent acknowledges these lessons and applies them.

## 3. Create Learnings

When the agent discovers something useful:

```
create_learning({
  learning_type: "scar",
  title: "OAuth redirect URI must match exactly",
  description: "Google OAuth rejects requests where the redirect URI doesn't match character-for-character...",
  severity: "medium",
  counter_arguments: [
    "In development, localhost variations are usually fine",
    "Some providers support wildcard redirects"
  ]
})
```

## 4. Close the Session

```
> "Let's wrap up"
```

The agent calls `session_close`, which persists:
- What was accomplished
- What scars were applied
- Open threads for next session
- A brief reflection

## What You Get

After a few sessions, GitMem builds a knowledge base of:
- **Scars** — Mistakes to avoid (surfaced automatically via recall)
- **Wins** — Approaches that worked well
- **Patterns** — Reusable strategies
- **Decisions** — Architectural choices with rationale
- **Threads** — Unfinished work that carries across sessions

========================================================================
# Free vs Pro
URL: https://gitmem.ai/docs/getting-started/free-vs-pro
Description: What you get today with the free tier and what's coming with Pro.
========================================================================

# Free vs Pro

GitMem ships with a fully functional free tier — everything you need to give your AI agents institutional memory. Pro will add cloud storage and team features.

## What's Included (Free Tier)

| Feature | How It Works |
|---------|-------------|
| **Session Management** | Local `.gitmem/` directory |
| **Recall (scar surfacing)** | BM25 text search over local scars |
| **Create scars/wins/patterns** | Local JSON files |
| **Threads** | Local tracking across sessions |
| **Session history** | Last session context loaded on start |
| **Semantic search** | Local search over learnings |
| **Multi-agent** | Context injection for agents on the same machine |
| **Analytics** | Basic session analytics |
| **Tools** | 23 core tools |

## Pro Tier — Coming Soon

Pro adds cloud-powered features for teams and power users:

| Feature | What Pro Adds |
|---------|--------------|
| **Storage** | Supabase PostgreSQL (persistent, cross-machine) |
| **Search** | pgvector semantic search with embeddings |
| **Multi-agent** | Shared cloud memory across machines |
| **Session history** | Full history with search |
| **Transcripts** | Save and search session transcripts |
| **Batch operations** | Batch scar recording |
| **Knowledge graph** | Triple-based graph traversal |
| **Cache management** | Status, health, and flush tools |
| **Tools** | 29 tools (6 additional) |

**Pro will be for you if:**
- You need shared memory across machines or teams
- You want full semantic search with embeddings
- You need session transcript storage
- You're running multi-agent workflows across environments

[Join the mailing list](https://gitmem.ai) to get notified when Pro launches.

========================================================================
# Overview
URL: https://gitmem.ai/docs/getting-started
Description: Get GitMem running in under 5 minutes.
========================================================================

# Getting Started

GitMem gives your AI coding agents institutional memory — the ability to learn from mistakes and remember what works across sessions.

## Prerequisites

- **Node.js 18+** (for `npx gitmem init`)
- An MCP-compatible client: [Claude Code](https://claude.com/claude-code), [Claude Desktop](https://claude.ai/download), or [Cursor](https://cursor.sh)

## Quick Start (30 seconds)

```bash
# In any project directory
npx gitmem init
```

The interactive wizard detects your existing config and sets up everything:
- `.gitmem/` directory with 12 starter scars
- `.mcp.json` with gitmem server entry
- `CLAUDE.md` with memory protocol instructions
- `.claude/settings.json` with lifecycle hooks and tool permissions
- `.gitignore` updated to exclude `.gitmem/`

Already have `.mcp.json`, `CLAUDE.md`, or hooks? The wizard merges without destroying your existing config. Re-running is safe — completed steps are skipped.

## What Happens Next

1. **Start a session** — Your agent calls `session_start` to load context
2. **Recall before acting** — Before consequential actions, `recall` surfaces relevant scars
3. **Learn from outcomes** — Create scars, wins, and patterns as you discover them
4. **Close cleanly** — `session_close` persists what happened for future sessions

## Next Steps

- [Installation](/docs/getting-started/installation) — Detailed setup for all environments
- [Configuration](/docs/getting-started/configuration) — Environment variables and config files
- [Your First Session](/docs/getting-started/first-session) — Step-by-step walkthrough
- [Free vs Pro](/docs/getting-started/free-vs-pro) — Tier comparison

========================================================================
# Installation
URL: https://gitmem.ai/docs/getting-started/installation
Description: Install GitMem via the init wizard, manual MCP config, or global install.
========================================================================

import { Tabs, Tab } from 'fumadocs-ui/components/tabs'
import { Steps, Step } from 'fumadocs-ui/components/steps'
import { Callout } from 'fumadocs-ui/components/callout'
import { Files, File, Folder } from 'fumadocs-ui/components/files'
import { Accordions, Accordion } from 'fumadocs-ui/components/accordion'

# Installation

<Tabs items={["Init Wizard (Recommended)", "Manual MCP Config", "Global Install"]}>
<Tab value="Init Wizard (Recommended)">

## Init Wizard

The recommended way to install GitMem. One command, interactive setup, safe to re-run.

```bash
cd your-project
npx gitmem init
```

<Steps>
<Step>
### Memory Store
Creates `.gitmem/` directory with 12 starter scars covering common mistakes.
</Step>
<Step>
### MCP Server
Adds gitmem to `.mcp.json` so your AI client can discover it.
</Step>
<Step>
### Project Instructions
Appends memory protocols to `CLAUDE.md` (or your client's instruction file).
</Step>
<Step>
### Tool Permissions
Adds `mcp__gitmem__*` to `.claude/settings.json` so tools work without manual approval.
</Step>
<Step>
### Lifecycle Hooks
Merges session start and recall hooks. Preserves your existing hooks.
</Step>
<Step>
### Gitignore
Adds `.gitmem/` to `.gitignore` — memory data stays local.
</Step>
</Steps>

### Flags

```bash
# Accept all defaults (non-interactive)
npx gitmem init --yes

# Preview what would change (no files written)
npx gitmem init --dry-run

# Set a project namespace
npx gitmem init --project my-app
```

<Callout type="info" title="Idempotent">
Re-running `npx gitmem init` is safe — completed steps are skipped with "Already configured."
</Callout>

### What Gets Created

<Files>
  <Folder name="your-project" defaultOpen>
    <Folder name=".gitmem" defaultOpen>
      <Folder name="scars">
        <File name="starter-scars.json" />
      </Folder>
      <File name="active-sessions.json" />
    </Folder>
    <Folder name=".claude">
      <File name="settings.json" />
    </Folder>
    <File name=".mcp.json" />
    <File name="CLAUDE.md" />
    <File name=".gitignore" />
  </Folder>
</Files>

### Uninstall

```bash
npx gitmem uninstall
```

Cleanly reverses everything init did. Your `.gitmem/` data is preserved by default.

```bash
# Also delete .gitmem/ memory data
npx gitmem uninstall --all
```

</Tab>
<Tab value="Manual MCP Config">

## Manual MCP Configuration

If you want to configure the MCP server without the init wizard.

<Tabs items={["Claude Code", "Claude Desktop", "Cursor"]}>
<Tab value="Claude Code">

```bash
claude mcp add gitmem -- npx -y gitmem-mcp
```

</Tab>
<Tab value="Claude Desktop">

Add to `~/Library/Application Support/Claude/claude_desktop_config.json`:

```json
{
  "mcpServers": {
    "gitmem": {
      "command": "npx",
      "args": ["-y", "gitmem-mcp"]
    }
  }
}
```

<Callout type="warn">
Restart Claude Desktop after saving the config file.
</Callout>

</Tab>
<Tab value="Cursor">

Add to `.cursor/mcp.json` in your project:

```json
{
  "mcpServers": {
    "gitmem": {
      "command": "npx",
      "args": ["-y", "gitmem-mcp"]
    }
  }
}
```

</Tab>
</Tabs>

</Tab>
<Tab value="Global Install">

## Global Install

```bash
npm install -g gitmem-mcp
```

Then reference the global binary in your MCP config:

```json
{
  "mcpServers": {
    "gitmem": {
      "command": "gitmem-mcp"
    }
  }
}
```

<Callout type="info">
Global install avoids the `npx` startup delay on each session. Useful for heavy users.
</Callout>

</Tab>
</Tabs>

---

## Verify Installation

After setup, ask your AI agent:

> "Run gitmem-help"

You should see a list of available commands with your current tier and tool count.

<Callout type="success" title="Working correctly?">
If `gitmem-help` returns a command list showing **23 tools (free tier)** or **29 tools (pro tier)**, you're good to go. Head to [Your First Session](/docs/getting-started/first-session) next.
</Callout>

## Environment Variables

| Variable | Default | Purpose |
|----------|---------|---------|
| `GITMEM_DIR` | `.gitmem/` | Storage directory |
| `GITMEM_DEFAULT_PROJECT` | `default` | Project namespace for scoping |

See [Configuration](/docs/getting-started/configuration) for full details.

## Troubleshooting

<Accordions type="single">
<Accordion title="npx gitmem init hangs or fails">
Ensure Node.js 18+ is installed (`node --version`). If behind a corporate proxy, try `npm install -g gitmem-mcp` first, then use `gitmem init` without npx.
</Accordion>
<Accordion title="Agent can't find gitmem tools">
Check that `.mcp.json` exists in your project root and contains the gitmem server entry. For Claude Desktop, verify the config path matches your OS. Restart the client after config changes.
</Accordion>
<Accordion title="Permission errors on tool calls">
Run `npx gitmem init` to add tool permissions to `.claude/settings.json`, or manually add `mcp__gitmem__*` to the `allow` array.
</Accordion>
<Accordion title="Starter scars show wrong age">
Starter scars use fixed creation dates. This is cosmetic — the scars function correctly regardless of displayed age.
</Accordion>
</Accordions>

========================================================================
# Closing Ceremony
URL: https://gitmem.ai/docs/guides/closing-ceremony
Description: How to properly close a GitMem session with reflection and persistence.
========================================================================

# Closing Ceremony

The closing ceremony is GitMem's session persistence ritual. It captures what happened, what was learned, and what carries forward.

## Quick Close vs Standard Close

| Type | When to Use | What Happens |
|------|-------------|--------------|
| **Quick** | Short sessions (< 30 min), purely exploratory | Minimal persistence, no reflection |
| **Standard** | All substantive work sessions | Full 9-question reflection |

## Standard Close Flow

### Step 1: Read Session State

The agent reads `.gitmem/active-sessions.json` to recover the session ID and any surfaced scars.

### Step 2: Answer 9 Questions

The agent reflects on:

1. **What broke** that you didn't expect?
2. **What took longer** than it should have?
3. **What would you do differently** next time?
4. **What pattern worked** well?
5. **What assumption was wrong?**
6. **Which scars** did you apply?
7. **What should be captured** as institutional memory?
8. **How did the human prefer to work?** (rapport)
9. **What collaborative dynamic** worked or didn't? (rapport)

### Step 3: Human Review

The agent asks: "Any corrections or additions?"

This human checkpoint prevents false learnings from being persisted.

### Step 4: Create Learnings

Any new scars, wins, or patterns identified in Q7 are created **before** session close.

### Step 5: Persist

`session_close` writes the full session record with:
- Close compliance metadata
- Scar usage records
- Open threads
- Rapport notes for the next session

## Writing the Payload

For standard closes, write heavy data to `.gitmem/closing-payload.json` before calling `session_close`. The tool reads this file automatically.

```json
{
  "closing_reflection": "Session focused on auth migration...",
  "task_completion": "partial",
  "scars_to_record": [],
  "open_threads": ["Rate limiting still needs implementation"],
  "decisions": ["Chose JWT over session cookies for stateless auth"]
}
```

========================================================================
# Error Handling
URL: https://gitmem.ai/docs/guides/error-handling
Description: Understanding and debugging GitMem errors.
========================================================================

# Error Handling

GitMem surfaces errors clearly so you can diagnose and fix issues quickly.

## Error Response Format

All tools return errors in a consistent format:

```json
{
  "success": false,
  "errors": ["Missing required field: severity"],
  "message": "Validation failed"
}
```

The `errors` array contains specific, actionable error messages.

## Common Errors

### Invalid Session ID

```
Error: Invalid session_id format. Expected UUID (e.g., '393adb34-xxxx-xxxx-xxxx-xxxxxxxxxxxx') or short ID (e.g., '393adb34'). Did you forget to run session_start first?
```

**Cause:** Passing a placeholder like `SESSION_AUTO` instead of a real session ID.
**Fix:** Call `session_start` first, then use the returned session ID.

### Missing Severity for Scars

```
Error: Missing required field: severity (must be critical, high, medium, or low)
```

**Cause:** Creating a scar without specifying severity.
**Fix:** Add `severity: "medium"` (or appropriate level) to your `create_learning` call.

### Missing Counter-Arguments

```
Error: Scars require at least 2 counter_arguments
```

**Cause:** Creating a scar with fewer than 2 counter-arguments.
**Fix:** Add at least 2 reasons why someone might reasonably ignore this scar.

## Silent Failure Prevention

GitMem tracks all fire-and-forget operations (metrics, cache writes, embeddings) via the Effect Tracker. Use `health` to see success/failure rates:

```
health({ failure_limit: 10 })
```

This surfaces any background operations that failed silently.

## MCP Transport Errors

If you see garbled JSON or "invalid JSON" errors in your MCP client:

1. GitMem uses `console.error` (stderr) for all diagnostics
2. `console.log` (stdout) is reserved for MCP JSON-RPC
3. If a plugin or extension writes to stdout, it corrupts the transport

Check that no other tools are writing to stdout in the same process.

========================================================================
# Multi-Agent Workflows
URL: https://gitmem.ai/docs/guides/multi-agent
Description: Inject institutional memory into sub-agents and capture their findings.
========================================================================

# Multi-Agent Workflows

GitMem helps coordinate teams of agents on a single machine. The lead agent can inject context into sub-agents and absorb their findings back into institutional memory.

> **Note:** Cross-machine shared memory requires the Pro tier (coming soon). The workflows below work on the free tier for agents running on the same machine.

## Context Injection

Before spawning a sub-agent, use `prepare_context` to generate a memory payload:

```
prepare_context({
  plan: "review authentication middleware",
  format: "compact"  // ~500 tokens
})
```

Formats:
- **`full`** — Rich markdown, unlimited tokens
- **`compact`** — ~500 tokens, one line per scar
- **`gate`** — ~100 tokens, blocking scars only

Include the payload in the sub-agent's prompt so it starts with institutional awareness.

## Absorbing Observations

When a sub-agent returns, capture its findings:

```
absorb_observations({
  observations: [
    {
      source: "Sub-Agent: code review",
      text: "Auth middleware doesn't validate token expiry",
      severity: "scar_candidate"
    },
    {
      source: "Sub-Agent: code review",
      text: "Good use of middleware pattern for request validation",
      severity: "info"
    }
  ]
})
```

Severity levels:
- **`info`** — Noteworthy but not actionable
- **`warning`** — Potential issue worth tracking
- **`scar_candidate`** — Should be promoted to a scar

## Best Practices

1. **Always `prepare_context` before spawning** — The 2-3 second cost prevents agents from repeating known mistakes
2. **Always `absorb_observations` after return** — Don't lose sub-agent findings
3. **Use `compact` format for most agents** — `gate` for simple tasks, `full` for complex reviews
4. **Scope by project** — Use project namespaces to keep memories relevant

========================================================================
# GitMem
URL: https://gitmem.ai/docs
Description: Institutional memory for AI coding agents. Memory that compounds.
========================================================================

import { Cards, Card } from 'fumadocs-ui/components/card'
import { Callout } from 'fumadocs-ui/components/callout'
import { Steps, Step } from 'fumadocs-ui/components/steps'

<div className="gitmem-hero">

# GitMem

Institutional memory for AI coding agents.
Every mistake learned from. Every win remembered.

<div className="memory-loop">
  <span className="step">recall</span>
  <span className="arrow">&rarr;</span>
  <span className="step">work</span>
  <span className="arrow">&rarr;</span>
  <span className="step">learn</span>
  <span className="arrow">&rarr;</span>
  <span className="step">close</span>
  <span className="arrow">&rarr;</span>
  <span className="step">recall</span>
</div>

<div className="hero-cta">
  <a href="/docs/getting-started/installation" className="primary">Get Started</a>
  <a href="https://github.com/gitmem-dev/gitmem" className="secondary">GitHub</a>
  <a href="/docs/tools" className="secondary">Tool Reference</a>
</div>

</div>

---

## What is GitMem?

Every time an AI agent makes a mistake, fixes a bug, or discovers a better approach, that knowledge disappears when the session ends. GitMem captures these lessons and surfaces them automatically before the agent takes similar actions.

<Cards>
  <Card title="Scars" href="/docs/concepts/scars">
    Mistakes captured as institutional memory. Surfaced automatically via recall before the agent repeats them.
  </Card>
  <Card title="Wins" href="/docs/concepts/learning-types">
    Approaches that worked well. Document what succeeded so it can be replicated.
  </Card>
  <Card title="Sessions" href="/docs/concepts/sessions">
    Bounded work periods with context loading, reflection, and clean closure.
  </Card>
  <Card title="Threads" href="/docs/concepts/threads">
    Unresolved work that carries across sessions. Never lose track of open items.
  </Card>
</Cards>

## Quick Start

<div className="install-block">

```bash
npx gitmem init
```

One command sets up everything: `.gitmem/` directory, `.mcp.json`, `CLAUDE.md`, hooks, and permissions. Already have existing config? The wizard merges without destroying anything.

</div>

## How It Works

<Steps>
<Step>
### Recall before acting

Before consequential actions, the agent checks institutional memory. Relevant scars surface automatically with severity and counter-arguments.

```
recall({ plan: "deploy to production" })
// → "Done ≠ Deployed ≠ Verified Working" (high severity)
// → "Database migrations must run before code deploy" (critical)
```

</Step>
<Step>
### Confirm and apply

Each scar must be acknowledged — **APPLYING** (with evidence), **N_A** (with reasoning), or **REFUTED** (acknowledging risk). No passive dismissal.

</Step>
<Step>
### Learn from outcomes

When something breaks or works well, capture it. Scars require counter-arguments to prevent knowledge bloat.

```
create_learning({
  learning_type: "scar",
  title: "OAuth redirect URI must match exactly",
  severity: "medium",
  counter_arguments: [
    "In development, localhost variations are usually fine",
    "Some providers support wildcard redirects"
  ]
})
```

</Step>
<Step>
### Close and persist

Session close captures reflections, records scar usage, and persists open threads for the next session.

</Step>
</Steps>

## Key Features

| Feature | Description |
|---------|-------------|
| **Automatic Recall** | Before taking action, agents check institutional memory for relevant lessons |
| **Confirm Protocol** | Scars require active acknowledgment — APPLYING, N_A, or REFUTED |
| **Session Continuity** | Context carries across sessions via threads, decisions, and rapport notes |
| **Multi-Agent** | Teams of agents share the same institutional memory via `prepare_context` |
| **MCP Native** | Works with Claude Code, Claude Desktop, Cursor, and any MCP client |
| **Free Tier** | Local `.gitmem/` storage with 23 tools, no external dependencies |

<Callout type="info" title="23 tools, zero cost">
The free tier includes session management, scar recall, learning creation, threads, and analytics — all stored locally in `.gitmem/`. No account, no API key, no cloud dependency.
</Callout>

## Explore

<Cards>
  <Card title="Getting Started" href="/docs/getting-started">
    Install GitMem and run your first session in under 5 minutes.
  </Card>
  <Card title="Concepts" href="/docs/concepts">
    Scars, sessions, threads, learning types, and tiers explained.
  </Card>
  <Card title="Tool Reference" href="/docs/tools">
    Complete documentation for all 29 GitMem tools.
  </Card>
  <Card title="Guides" href="/docs/guides">
    Closing ceremony, multi-agent workflows, and error handling.
  </Card>
  <Card title="Contributing" href="/docs/contributing">
    Development setup, testing tiers, and code style.
  </Card>
  <Card title="Changelog" href="/docs/changelog">
    Release history and what's new.
  </Card>
</Cards>

========================================================================
# absorb_observations
URL: https://gitmem.ai/docs/tools/absorb-observations
Description: Capture observations from sub-agents and teammates.
========================================================================

# absorb_observations

**Tier:** Free · **Aliases:** `gitmem-ao`, `gm-absorb`

Capture observations from sub-agents and teammates. The lead agent parses findings from sub-agent responses, then calls this to persist and analyze them. Identifies scar candidates.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `task_id` | string | No | Linear issue or task identifier (optional) |
| `observations` | object[] | Yes | Array of observations from sub-agents/teammates |

### observations items

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `source` | string | Yes | Who made this observation (e.g., "Sub-Agent: code review") |
| `text` | string | Yes | What was observed |
| `severity` | `"info"` \| `"warning"` \| `"scar_candidate"` | Yes | Observation severity |
| `context` | string | No | File, function, or area (optional) |

========================================================================
# analyze
URL: https://gitmem.ai/docs/tools/analyze
Description: Session analytics and insights engine.
========================================================================

# analyze

**Tier:** Pro · **Aliases:** `gitmem-analyze`, `gm-analyze`

Session analytics and insights engine. Returns formatted markdown by default. Use format=json for raw data.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `lens` | `"summary"` \| `"reflections"` \| `"blindspots"` | No | Analysis lens to apply (default: summary) |
| `days` | number | No | Number of days to analyze (default: 30) |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |
| `agent` | string | No | Filter by agent identity (e.g., cli, desktop, autonomous) |
| `format` | `"text"` \| `"json"` | No | Output format: text (default, compact markdown) or json (raw data) |

========================================================================
# archive_learning
URL: https://gitmem.ai/docs/tools/archive-learning
Description: Archives a learning (scar/win/pattern) by setting is_active=false and recording archived_at timestamp.
========================================================================

# archive_learning

**Tier:** Pro · **Aliases:** `gitmem-al`, `gm-archive`

Archives a learning (scar/win/pattern) by setting is_active=false and recording archived_at timestamp. Archived learnings are excluded from recall and search results but preserved for audit trail.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | string | Yes | UUID of the learning to archive |
| `reason` | string | No | Optional reason for archiving (e.g., 'superseded by PROJ-123', 'no longer relevant') |

========================================================================
# gitmem-cache-flush
URL: https://gitmem.ai/docs/tools/cache-flush
Description: gitmem-cache-flush - Force reload cache from Supabase (use when out of sync).
========================================================================

# gitmem-cache-flush

**Tier:** Pro · **Aliases:** `gm-cache-f`

gitmem-cache-flush - Force reload cache from Supabase (use when out of sync)

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |

========================================================================
# gitmem-cache-health
URL: https://gitmem.ai/docs/tools/cache-health
Description: gitmem-cache-health - Compare local cache against remote Supabase (detect out-of-sync).
========================================================================

# gitmem-cache-health

**Tier:** Pro · **Aliases:** `gm-cache-h`

gitmem-cache-health - Compare local cache against remote Supabase (detect out-of-sync)

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |

========================================================================
# gitmem-cache-status
URL: https://gitmem.ai/docs/tools/cache-status
Description: gitmem-cache-status - Show local search cache status (scar count, age, staleness).
========================================================================

# gitmem-cache-status

**Tier:** Pro · **Aliases:** `gm-cache-s`

gitmem-cache-status - Show local search cache status (scar count, age, staleness)

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |

========================================================================
# cleanup_threads
URL: https://gitmem.ai/docs/tools/cleanup-threads
Description: Triage open threads by lifecycle health.
========================================================================

# cleanup_threads

**Tier:** Free · **Aliases:** `gitmem-cleanup`, `gm-cleanup`

Triage open threads by lifecycle health. Groups threads as active/cooling/dormant with vitality scores. Use auto_archive=true to archive threads dormant 30+ days. Review and resolve stale threads to keep your thread list healthy.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |
| `auto_archive` | boolean | No | If true, auto-archive threads that have been dormant for 30+ days |

========================================================================
# confirm_scars
URL: https://gitmem.ai/docs/tools/confirm-scars
Description: Confirm surfaced scars with APPLYING/N_A/REFUTED decisions and evidence.
========================================================================

# confirm_scars

**Tier:** Free · **Aliases:** `gitmem-cs`, `gm-confirm`

Confirm surfaced scars with APPLYING/N_A/REFUTED decisions and evidence. REQUIRED after recall() before consequential actions. Each recalled scar must be addressed. APPLYING: past-tense evidence of compliance. N_A: explain why scar doesn't apply. REFUTED: acknowledge risk of overriding.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `confirmations` | object[] | Yes | One confirmation per recalled scar. All recalled scars must be addressed. |

### confirmations items

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `scar_id` | string | Yes | UUID of the surfaced scar (from recall result) |
| `decision` | `"APPLYING"` \| `"N_A"` \| `"REFUTED"` | Yes | APPLYING: scar is relevant, evidence of compliance. N_A: scar doesn't apply, explain why. REFUTED: overriding scar, acknowledge risk. |
| `evidence` | string | Yes | Past-tense evidence (APPLYING), scenario comparison (N_A), or risk acknowledgment (REFUTED). Minimum 50 characters. |
| `relevance` | `"high"` \| `"low"` \| `"noise"` | No | How relevant was this scar to your plan? high=directly applicable, low=tangentially related, noise=not relevant to this context. Helps improve future recall quality. |

========================================================================
# create_decision
URL: https://gitmem.ai/docs/tools/create-decision
Description: Log architectural/operational decision to institutional memory.
========================================================================

# create_decision

**Tier:** Free · **Aliases:** `gitmem-cd`

Log architectural/operational decision to institutional memory

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `title` | string | Yes | Decision title |
| `decision` | string | Yes | What was decided |
| `rationale` | string | Yes | Why this decision was made |
| `alternatives_considered` | string[] | No | Alternatives that were rejected |
| `personas_involved` | string[] | No | Personas involved in decision |
| `docs_affected` | string[] | No | Docs/files affected by this decision (relative paths from repo root) |
| `linear_issue` | string | No | Associated Linear issue |
| `session_id` | string | No | Current session ID |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |

========================================================================
# create_learning
URL: https://gitmem.ai/docs/tools/create-learning
Description: Create scar, win, or pattern entry in institutional memory.
========================================================================

# create_learning

**Tier:** Free · **Aliases:** `gitmem-cl`, `gm-scar`

Create scar, win, or pattern entry in institutional memory. Frame as 'what we now know' — lead with the factual/architectural discovery, not what went wrong. Good: 'Fine-grained PATs are scoped to one resource owner'. Bad: 'Should have checked PAT type first'.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `learning_type` | `"scar"` \| `"win"` \| `"pattern"` \| `"anti_pattern"` | Yes | Type of learning |
| `title` | string | Yes | Frame as a knowledge discovery — what we now know. Lead with the factual insight, not self-criticism. |
| `description` | string | Yes | Detailed description. Include the architectural/behavioral fact that makes this retrievable by domain. |
| `severity` | `"critical"` \| `"high"` \| `"medium"` \| `"low"` | No | Severity level (required for scars) |
| `scar_type` | `"process"` \| `"incident"` \| `"context"` | No | Scar type (process, incident, or context). Defaults to 'process'. |
| `counter_arguments` | string[] | No | Counter-arguments for scars (min 2 required) |
| `problem_context` | string | No | Problem context (for wins) |
| `solution_approach` | string | No | Solution approach (for wins) |
| `applies_when` | string[] | No | When this pattern applies |
| `domain` | string[] | No | Domain tags |
| `keywords` | string[] | No | Search keywords |
| `source_linear_issue` | string | No | Source Linear issue |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |

========================================================================
# create_thread
URL: https://gitmem.ai/docs/tools/create-thread
Description: Create an open thread to track unresolved work across sessions.
========================================================================

# create_thread

**Tier:** Free · **Aliases:** `gitmem-ct`, `gm-thread-new`

Create an open thread to track unresolved work across sessions. Includes semantic dedup: if a similar open thread exists (cosine similarity > 0.85), returns the existing thread instead. Check the 'deduplicated' field in the response.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `text` | string | Yes | Thread description — what needs to be tracked or resolved |
| `linear_issue` | string | No | Associated Linear issue (e.g., PROJ-123) |

========================================================================
# dismiss_suggestion
URL: https://gitmem.ai/docs/tools/dismiss-suggestion
Description: Dismiss a suggested thread.
========================================================================

# dismiss_suggestion

**Tier:** Free · **Aliases:** `gitmem-ds`, `gm-dismiss`

Dismiss a suggested thread. Incremented dismiss count — suggestions dismissed 3+ times are permanently suppressed.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `suggestion_id` | string | Yes | Suggestion ID (e.g., "ts-a1b2c3d4") from suggested_threads list |

========================================================================
# get_transcript
URL: https://gitmem.ai/docs/tools/get-transcript
Description: Retrieve a session transcript from storage.
========================================================================

# get_transcript

**Tier:** Dev · **Aliases:** `gitmem-gt`

Retrieve a session transcript from storage

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `session_id` | string | Yes | Session ID to retrieve transcript for |

========================================================================
# graph_traverse
URL: https://gitmem.ai/docs/tools/graph-traverse
Description: Traverse the knowledge graph over institutional memory triples.
========================================================================

# graph_traverse

**Tier:** Pro · **Aliases:** `gitmem-graph`, `gm-graph`

Traverse the knowledge graph over institutional memory triples. Answers: 'show me everything connected to this issue', 'what did this agent produce', 'trace this decision back', 'which issues produced the most learnings'. Four lenses: connected_to, produced_by, provenance, stats.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `lens` | `"connected_to"` \| `"produced_by"` \| `"provenance"` \| `"stats"` | Yes | Traversal mode: connected_to (all connections to a node), produced_by (what an agent/persona produced), provenance (trace origin chain), stats (aggregate counts) |
| `node` | string | No | Starting node. Examples: 'PROJ-123', 'cli', 'Scar: Done ≠ Deployed'. Required for all lenses except stats. |
| `predicate` | `"created_in"` \| `"influenced_by"` \| `"supersedes"` \| `"demonstrates"` | No | Filter by predicate (optional) |
| `depth` | number | No | Max chain depth for provenance lens (default: 3) |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |
| `limit` | number | No | Max triples to return (default: 50) |

========================================================================
# health
URL: https://gitmem.ai/docs/tools/health
Description: Show write health for the current session.
========================================================================

# health

**Tier:** Free · **Aliases:** `gitmem-health`, `gm-health`

Show write health for the current session. Reports success/failure rates for all tracked fire-and-forget operations (metrics, cache, triple writes, embeddings, scar usage). Use this to diagnose silent failures.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `failure_limit` | number | No | Max number of recent failures to return (default: 10) |

========================================================================
# gitmem-help
URL: https://gitmem.ai/docs/tools/help
Description: gitmem-help - Show available commands with ASCII art header.
========================================================================

# gitmem-help

**Tier:** Free

gitmem-help - Show available commands with ASCII art header

========================================================================
# Tool Reference
URL: https://gitmem.ai/docs/tools
Description: Complete reference for all GitMem MCP tools.
========================================================================

# Tool Reference

GitMem exposes tools via the [Model Context Protocol](https://modelcontextprotocol.io). Each tool has a canonical name and short aliases for convenience.

## Core Tools (All Tiers)

### Session Management

| Tool | Aliases | Purpose |
|------|---------|---------|
| [session_start](/docs/tools/session-start) | `gitmem-ss`, `gm-open` | Initialize session with context |
| [session_refresh](/docs/tools/session-refresh) | `gitmem-sr`, `gm-refresh` | Reload context mid-session |
| [session_close](/docs/tools/session-close) | `gitmem-sc`, `gm-close` | Close session with reflection |

### Memory Operations

| Tool | Aliases | Purpose |
|------|---------|---------|
| [recall](/docs/tools/recall) | `gitmem-r` | Surface relevant scars before acting |
| [confirm_scars](/docs/tools/confirm-scars) | `gitmem-cs`, `gm-confirm` | Confirm recalled scars (APPLYING/N_A/REFUTED) |
| [create_learning](/docs/tools/create-learning) | `gitmem-cl`, `gm-scar` | Create scar/win/pattern |
| [create_decision](/docs/tools/create-decision) | `gitmem-cd` | Log architectural decision |
| [record_scar_usage](/docs/tools/record-scar-usage) | `gitmem-rs` | Track scar application |

### Search and Discovery

| Tool | Aliases | Purpose |
|------|---------|---------|
| [search](/docs/tools/search) | `gitmem-search`, `gm-search` | Explore institutional memory |
| [log](/docs/tools/log) | `gitmem-log`, `gm-log` | List recent learnings |
| [analyze](/docs/tools/analyze) | `gitmem-analyze`, `gm-analyze` | Session analytics |

### Thread Management

| Tool | Aliases | Purpose |
|------|---------|---------|
| [list_threads](/docs/tools/list-threads) | `gitmem-lt`, `gm-threads` | List open threads |
| [create_thread](/docs/tools/create-thread) | `gitmem-ct`, `gm-thread-new` | Create thread with dedup |
| [resolve_thread](/docs/tools/resolve-thread) | `gitmem-rt`, `gm-resolve` | Mark thread resolved |
| [promote_suggestion](/docs/tools/promote-suggestion) | `gitmem-ps`, `gm-promote` | Promote suggested thread |
| [dismiss_suggestion](/docs/tools/dismiss-suggestion) | `gitmem-ds`, `gm-dismiss` | Dismiss suggested thread |
| [cleanup_threads](/docs/tools/cleanup-threads) | `gitmem-cleanup`, `gm-cleanup` | Triage by health |

### Multi-Agent

| Tool | Aliases | Purpose |
|------|---------|---------|
| [prepare_context](/docs/tools/prepare-context) | `gitmem-pc`, `gm-pc` | Memory payload for sub-agents |
| [absorb_observations](/docs/tools/absorb-observations) | `gitmem-ao`, `gm-absorb` | Capture sub-agent findings |

### Utility

| Tool | Aliases | Purpose |
|------|---------|---------|
| [graph_traverse](/docs/tools/graph-traverse) | `gitmem-graph`, `gm-graph` | Knowledge graph traversal |
| [archive_learning](/docs/tools/archive-learning) | `gitmem-al`, `gm-archive` | Archive a learning |
| [health](/docs/tools/health) | `gitmem-health`, `gm-health` | Write health report |
| `gitmem-help` | — | Show available commands |

## Pro-Only Tools (Coming Soon)

These tools will be available when the Pro tier launches:

| Tool | Aliases | Purpose |
|------|---------|---------|
| record_scar_usage_batch | `gitmem-rsb` | Batch scar recording |
| save_transcript | `gitmem-st` | Save session transcript |
| get_transcript | `gitmem-gt` | Retrieve transcript |
| search_transcripts | `gitmem-stx`, `gm-stx` | Search transcripts |
| cache_status | `gitmem-cache-status`, `gm-cache-s` | Cache status |
| cache_health | `gitmem-cache-health`, `gm-cache-h` | Cache vs remote comparison |
| cache_flush | `gitmem-cache-flush`, `gm-cache-f` | Force cache reload |

========================================================================
# list_threads
URL: https://gitmem.ai/docs/tools/list-threads
Description: List open threads across recent sessions.
========================================================================

# list_threads

**Tier:** Free · **Aliases:** `gitmem-lt`, `gm-threads`

List open threads across recent sessions. Shows unresolved work items that carry over between sessions, with IDs for resolution. Use resolve_thread to mark threads as done.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `status` | `"open"` \| `"resolved"` | No | Filter by status (default: open) |
| `include_resolved` | boolean | No | Include recently resolved threads (default: false) |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |

========================================================================
# log
URL: https://gitmem.ai/docs/tools/log
Description: List recent learnings chronologically (like git log).
========================================================================

# log

**Tier:** Free · **Aliases:** `gitmem-log`, `gm-log`

List recent learnings chronologically (like git log). Shows scars, wins, and patterns ordered by creation date.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `limit` | number | No | Number of entries to return (default: 10) |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |
| `learning_type` | `"scar"` \| `"win"` \| `"pattern"` \| `"anti_pattern"` | No | Filter by learning type |
| `severity` | `"critical"` \| `"high"` \| `"medium"` \| `"low"` | No | Filter by severity level |
| `since` | number | No | Days to look back (e.g., 7 = last week) |

========================================================================
# prepare_context
URL: https://gitmem.ai/docs/tools/prepare-context
Description: Generate portable memory payload for sub-agent injection.
========================================================================

# prepare_context

**Tier:** Free · **Aliases:** `gitmem-pc`, `gm-pc`

Generate portable memory payload for sub-agent injection. Formats institutional memory into compact or gate payloads that fit in Task tool prompts.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `plan` | string | Yes | What the team is about to do (e.g., 'review auth middleware', 'deploy edge function') |
| `format` | `"full"` \| `"compact"` \| `"gate"` | Yes | Output format: full (rich markdown), compact (~500 tokens, one-line per scar), gate (~100 tokens, blocking scars only) |
| `max_tokens` | number | No | Token budget for payload (default: 500 for compact, 100 for gate, unlimited for full) |
| `agent_role` | string | No | Sub-agent role for relevance filtering (e.g., 'reviewer', 'deployer') — reserved for Phase 3 |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |

========================================================================
# promote_suggestion
URL: https://gitmem.ai/docs/tools/promote-suggestion
Description: Promote a suggested thread to an open thread.
========================================================================

# promote_suggestion

**Tier:** Free · **Aliases:** `gitmem-ps`, `gm-promote`

Promote a suggested thread to an open thread. Takes a suggestion_id from session_start's suggested_threads list and creates a real thread from it.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `suggestion_id` | string | Yes | Suggestion ID (e.g., "ts-a1b2c3d4") from suggested_threads list |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |

========================================================================
# recall
URL: https://gitmem.ai/docs/tools/recall
Description: Check institutional memory for relevant scars before taking action.
========================================================================

# recall

**Tier:** Free · **Aliases:** `gitmem-r`

Check institutional memory for relevant scars before taking action. Returns matching scars and their lessons. Integrates variant assignment when issue_id provided.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `plan` | string | Yes | What you're about to do (e.g., 'implement auth layer', 'deploy to production') |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |
| `match_count` | number | No | Number of scars to return (default: 3) |
| `issue_id` | string | No | Linear issue identifier for variant assignment (e.g., 'PROJ-123'). When provided, scars with variants will be randomly assigned and formatted accordingly. |
| `similarity_threshold` | number | No | Minimum similarity score (0-1) to include results. Weak matches below threshold are suppressed. Default: 0.4 (free tier BM25), 0.35 (pro tier embeddings). |

========================================================================
# record_scar_usage_batch
URL: https://gitmem.ai/docs/tools/record-scar-usage-batch
Description: Track multiple scar applications in a single batch operation (reduces session close latency).
========================================================================

# record_scar_usage_batch

**Tier:** Dev · **Aliases:** `gitmem-rsb`

Track multiple scar applications in a single batch operation (reduces session close latency)

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `scars` | object[] | Yes | Array of scar usage entries to record |
| `project` | string | No | Project scope for scar resolution |

### scars items

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `scar_identifier` | string | Yes | UUID or title/description of scar (tool resolves to UUID) |
| `issue_id` | string | No | Linear issue UUID |
| `issue_identifier` | string | No | Linear issue identifier (e.g., PROJ-123) |
| `surfaced_at` | string | Yes | ISO timestamp when scar was retrieved |
| `acknowledged_at` | string | No | ISO timestamp when scar was acknowledged |
| `reference_type` | `"explicit"` \| `"implicit"` \| `"acknowledged"` \| `"refuted"` \| `"none"` | Yes | How the scar was referenced |
| `reference_context` | string | Yes | How the scar was applied (1-2 sentences) |
| `execution_successful` | boolean | No | Whether the task succeeded after applying scar |
| `session_id` | string | No | GitMem session UUID (for non-issue session tracking) |
| `agent` | string | No | Agent identity (e.g., cli, desktop, autonomous) |

========================================================================
# record_scar_usage
URL: https://gitmem.ai/docs/tools/record-scar-usage
Description: Track scar application for effectiveness measurement.
========================================================================

# record_scar_usage

**Tier:** Free · **Aliases:** `gitmem-rs`

Track scar application for effectiveness measurement

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `scar_id` | string | Yes | UUID of the scar |
| `issue_id` | string | No | Linear issue UUID |
| `issue_identifier` | string | No | Linear issue identifier (e.g., PROJ-123) |
| `surfaced_at` | string | Yes | ISO timestamp when scar was retrieved |
| `acknowledged_at` | string | No | ISO timestamp when scar was acknowledged |
| `reference_type` | `"explicit"` \| `"implicit"` \| `"acknowledged"` \| `"refuted"` \| `"none"` | Yes | How the scar was referenced |
| `reference_context` | string | Yes | How the scar was applied (1-2 sentences) |
| `execution_successful` | boolean | No | Whether the task succeeded after applying scar |
| `session_id` | string | No | GitMem session UUID (for non-issue session tracking) |
| `agent` | string | No | Agent identity (e.g., cli, desktop, autonomous) |
| `variant_id` | string | No | UUID of the assigned variant from scar_enforcement_variants (for A/B testing) |

========================================================================
# resolve_thread
URL: https://gitmem.ai/docs/tools/resolve-thread
Description: Mark an open thread as resolved.
========================================================================

# resolve_thread

**Tier:** Free · **Aliases:** `gitmem-rt`, `gm-resolve`

Mark an open thread as resolved. Use thread_id for exact match or text_match for fuzzy matching. Updates session state and .gitmem/threads.json.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `thread_id` | string | No | Thread ID (e.g., "t-a1b2c3d4") for exact resolution |
| `text_match` | string | No | Fuzzy text match against thread descriptions (fallback if no thread_id) |
| `resolution_note` | string | No | Brief note explaining how/why thread was resolved |

========================================================================
# save_transcript
URL: https://gitmem.ai/docs/tools/save-transcript
Description: Save full session transcript to storage for training data and post-mortems.
========================================================================

# save_transcript

**Tier:** Dev · **Aliases:** `gitmem-st`

Save full session transcript to storage for training data and post-mortems

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `session_id` | string | Yes | Session ID to associate transcript with |
| `transcript` | string | Yes | Full conversation transcript content |
| `format` | `"json"` \| `"markdown"` | No | Transcript format (default: json) |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |

========================================================================
# search_transcripts
URL: https://gitmem.ai/docs/tools/search-transcripts
Description: Semantic search over session transcript chunks.
========================================================================

# search_transcripts

**Tier:** Dev · **Aliases:** `gitmem-stx`, `gm-stx`

Semantic search over session transcript chunks. Generates embedding for query and calls match_transcript_chunks RPC to find relevant conversation fragments across all indexed sessions.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `query` | string | Yes | Natural language search query (e.g., 'deployment verification discussion', 'what was decided about caching') |
| `match_count` | number | No | Maximum number of chunks to return (default: 10, max: 50) |
| `similarity_threshold` | number | No | Minimum similarity score 0-1 (default: 0.3). Higher values return more relevant results. |
| `project` | string | No | Project namespace to filter by (e.g., 'my-project') |

========================================================================
# search
URL: https://gitmem.ai/docs/tools/search
Description: Search institutional memory by query.
========================================================================

# search

**Tier:** Free · **Aliases:** `gitmem-search`, `gm-search`

Search institutional memory by query. Unlike recall (which is action-oriented), search is exploration-oriented — returns matching scars/wins/patterns without side effects.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `query` | string | Yes | Natural language search query (e.g., 'deployment failures', 'Supabase RLS') |
| `match_count` | number | No | Number of results to return (default: 5) |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |
| `severity` | `"critical"` \| `"high"` \| `"medium"` \| `"low"` | No | Filter by severity level |
| `learning_type` | `"scar"` \| `"win"` \| `"pattern"` \| `"anti_pattern"` | No | Filter by learning type |

========================================================================
# session_close
URL: https://gitmem.ai/docs/tools/session-close
Description: Persist session with compliance validation.
========================================================================

# session_close

**Tier:** Free · **Aliases:** `gitmem-sc`, `gm-close`

Persist session with compliance validation. IMPORTANT: Before calling this tool, write all heavy payload data (closing_reflection, task_completion, human_corrections, scars_to_record, open_threads, decisions, learnings_created) to `gitmem_dir`/closing-payload.json using your file write tool — the gitmem_dir path is returned by session_start (also shown in session start display as 'Payload path'). Then call this tool with ONLY session_id and close_type. The tool reads the payload file automatically and deletes it after processing. Output the display field verbatim as your response — tool results are collapsed in the CLI.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `session_id` | string | Yes | Session ID from session_start |
| `close_type` | `"standard"` \| `"quick"` \| `"autonomous"` | Yes | Type of close (standard requires full reflection) |
| `linear_issue` | string | No | Associated Linear issue |
| `ceremony_duration_ms` | number | No | End-to-end ceremony duration from agent perspective (in milliseconds) |

========================================================================
# session_refresh
URL: https://gitmem.ai/docs/tools/session-refresh
Description: Re-surface institutional context (threads, decisions) for the current active session without creating a new session.
========================================================================

# session_refresh

**Tier:** Free · **Aliases:** `gitmem-sr`, `gm-refresh`

Re-surface institutional context (threads, decisions) for the current active session without creating a new session. Use mid-session when you need to remember where you left off, after context compaction, or after a long gap. Output the display field verbatim as your response — tool results are collapsed in the CLI.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `project` | string | No | Project namespace (default: from active session). Free-form string (e.g., 'my-project'). |

========================================================================
# session_start
URL: https://gitmem.ai/docs/tools/session-start
Description: Initialize session, detect agent, load institutional context (last session, recent decisions, open threads).
========================================================================

# session_start

**Tier:** Free · **Aliases:** `gitmem-ss`, `gm-open`

Initialize session, detect agent, load institutional context (last session, recent decisions, open threads). Scars surface on-demand via recall(). Output the display field verbatim as your response — tool results are collapsed in the CLI.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `agent_identity` | `"cli"` \| `"desktop"` \| `"autonomous"` \| `"local"` \| `"cloud"` | No | Override agent identity (auto-detects if not provided) |
| `linear_issue` | string | No | Current Linear issue identifier (e.g., PROJ-123) |
| `issue_title` | string | No | Issue title for scar context |
| `issue_description` | string | No | Issue description for scar context |
| `issue_labels` | string[] | No | Issue labels for scar context |
| `project` | string | No | Project namespace (e.g., 'my-project'). Scopes sessions and searches. |
| `force` | boolean | No | Force create new session even if one already exists |

