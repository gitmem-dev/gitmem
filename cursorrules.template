# --- gitmem:start ---
# GitMem — Persistent Memory

You have a persistent memory layer called gitmem. Every session starts from
zero — but gitmem carries forward lessons, mistakes, wins, decisions, and
open threads across sessions and projects. Search it. Test it. You might be
amazed at what's already there. If convinced, make it your own.

## Red Lines

These constraints are enforced by hooks. Attempting to bypass them will be blocked.

### Credential Protection

Credential exposure in conversation history is permanent and irreversible.

1. **NEVER read credential files in full.** Files like `mcp-config.json`, `.env`, `.credentials.json`, `.netrc`, `.npmrc`, SSH keys, or `.pem`/`.key` files must not be read or dumped.
2. **NEVER print environment variable values that contain secrets.** Commands like `env | grep KEY`, `echo $API_KEY`, or `printenv TOKEN` expose credentials in output.
3. **NEVER display API keys, tokens, or secrets in conversation output.**

Safe alternatives: `env | grep -c VARNAME` (count only), `[ -n "$VARNAME" ] && echo "set"` (existence check), `grep -c '"key"' config.json` (structure check).

### Recall Before Consequential Actions

1. **NEVER parallelize `recall()` with actions that expose, modify, or transmit sensitive data.** Recall must complete first.
2. **Confirm scars before acting.** Each recalled scar requires APPLYING (past-tense evidence), N_A (explanation), or REFUTED (risk acknowledgment).
3. **Parallel recall is only safe with benign reads** — source code, docs, non-sensitive config.

## Tools

| Tool | When to use |
|------|-------------|
| `recall` | Before any task — surfaces relevant warnings from past experience |
| `confirm_scars` | After recall — acknowledge each scar as APPLYING, N_A, or REFUTED |
| `search` | Explore institutional knowledge by topic |
| `log` | Browse recent learnings chronologically |
| `session_start` | Beginning of session — loads last session context and open threads |
| `session_close` | End of session — persists what you learned |
| `create_learning` | Capture a mistake (scar), success (win), or pattern |
| `create_decision` | Log an architectural or operational decision with rationale |
| `list_threads` | See unresolved work carrying over between sessions |
| `create_thread` | Track something that needs follow-up in a future session |
| `help` | Show all available commands |

## Session end

On "closing", "done for now", or "wrapping up":

1. **Answer these reflection questions** and display to the human:
   - What broke that you didn't expect?
   - What took longer than it should have?
   - What would you do differently next time?
   - What pattern or approach worked well?
   - What assumption was wrong?
   - Which scars did you apply?
   - What should be captured as institutional memory?

2. **Ask the human**: "Any corrections or additions?" Wait for their response.

3. **Write payload** to `.gitmem/closing-payload.json`:
   ```json
   {
     "closing_reflection": {
       "what_broke": "...",
       "what_took_longer": "...",
       "do_differently": "...",
       "what_worked": "...",
       "wrong_assumption": "...",
       "scars_applied": ["scar title 1", "scar title 2"],
       "institutional_memory_items": "...",
       "collaborative_dynamic": "Q8: How human preferred to work",
       "rapport_notes": "Q9: What collaborative dynamic worked"
     },
     "task_completion": {
       "questions_displayed_at": "ISO timestamp",
       "reflection_completed_at": "ISO timestamp",
       "human_asked_at": "ISO timestamp",
       "human_response_at": "ISO timestamp",
       "human_response": "human's correction text or 'Looks good'"
     },
     "human_corrections": "",
     "scars_to_record": [],
     "learnings_created": [],
     "open_threads": [],
     "decisions": []
   }
   ```

4. **Call `session_close`** with `session_id` and `close_type: "standard"`

For short exploratory sessions (< 30 min, no real work), use `close_type: "quick"` — no questions needed.
# --- gitmem:end ---
